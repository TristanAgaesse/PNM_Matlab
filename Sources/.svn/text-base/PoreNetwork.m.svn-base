classdef  PoreNetwork 
    %PoreNetwork 
    %Abstract class : superclasse de PoreNetwork mesh (r�seau non structur�) ou PoreNetwork
    %regulier.
    
    
    properties %(SetAccess = protected, GetAccess = protected)
        FaceOwners  %%tableau 1*NombreFaces, FaceOwners(i)=num�ro d'un pore voisin
        FaceNeighbours  %tableau 1*NombreFaces, FaceNeighbours(i)=-1 si face sur une fronti�re
        Pores  %structure, Pores{i}=tableau avec numero des liens de la cellule i
        Boundaries  %structure Boundaries.Boundary{i}=infos structur�es sur une fronti�re
        Dimension
        NombreFaces
        NombrePores
        PoreDataList
        LinkDataList
    end
       
    methods
        function poreNetwork=PoreNetwork(dimension,pores,owners,neighbours,boundaries)
            
            poreNetwork.Dimension=dimension;
            poreNetwork.NombreFaces=length(owners);
            poreNetwork.Pores=pores;
            poreNetwork.NombrePores=length(pores);
            poreNetwork.FaceOwners=owners;
            poreNetwork.FaceNeighbours=neighbours;
            poreNetwork.Boundaries=boundaries;
            
            data_pore_list=DataPoreList(poreNetwork.NombrePores);
            poreNetwork.PoreDataList=data_pore_list;
            data_link_list=DataLinkList(poreNetwork.NombreFaces);
            poreNetwork.LinkDataList=data_link_list;
            
        end
        
        
        function number=GetNumberOfPores(poreNetwork)
            number=poreNetwork.NombrePores;
        end
        
        function number=GetNumberOfLinks(poreNetwork)
            number=poreNetwork.NombreFaces;
        end
        
        
        
        function liste_pores_voisins=GetPoresVoisinsOfPore(poreNetwork,num_pore)
            liste_liens=poreNetwork.Pores{num_pore};
            liste_pores_voisins=zeros(1,length(liste_liens));
            for i=1:length(liste_liens)
                num_owner=poreNetwork.FaceOwners(liste_liens(i));
                num_neighbour=poreNetwork.FaceNeighbours(liste_liens(i));
                if num_owner==num_pore
                    liste_pores_voisins(i)=num_neighbour;
                else
                    liste_pores_voisins(i)=num_owner;
                end
            end
            
        end
        
        function indices=GetPoresOfLink(poreNetwork,num_link)
            indices=zeros(1,2);
            indices(1)=poreNetwork.FaceNeighbours(num_link);
            indices(2)=poreNetwork.FaceOwners(num_link);
        end
        
        function indices=GetLinksOfPore(poreNetwork,num_pore)
            indices=poreNetwork.Pores{num_pore};
        end

        function face=GetCommonFace(poreNetwork,pore1,pore2) 
            face=poreNetwork.Pores{pore1}(ismember(poreNetwork.Pores{pore1},poreNetwork.Pores{pore2}));
            assert(length(face)==1,'Pb GetCommonFace');
        end
        
        
        %Data lists
        function data_struct=GetPoreDataList(poreNetwork)
            data_struct=poreNetwork.PoreDataList.PoreDatas;
        end       
        
        function AddNewPoreData(poreNetwork,data,name)
            poreNetwork.PoreDataList.AddData(name,data);
        end
               
        function RemovePoreData(poreNetwork,name)
            poreNetwork.PoreDataList.RemoveData(name);
        end        
        
        function data_struct=GetLinkDataList(poreNetwork)
            data_struct=poreNetwork.LinkDataList.LinkDatas;
        end       
        
        function dim=GetDimension(poreNetwork)
            dim=poreNetwork.Dimension;
        end
        
        function AddNewLinkData(poreNetwork,data,name)
            poreNetwork.LinkDataList.AddData(name,data);
        end
        
        function RemoveLinkData(poreNetwork,name)
            poreNetwork.LinkDataList.RemoveData(name);
        end
        
        function diameter=GetLinkDiameter(poreNetwork,iLink)
            if not(isfield(poreNetwork.GetLinkDataList,'Diameter'))
                disp('Calcul du diam�tre des liens...');
                tic;
                nLink=poreNetwork.GetNumberOfLinks;
                diameters=zeros(1,nLink);
               for iLink=1:nLink
                    diameters(iLink)=poreNetwork.ComputeLinkDiameter(iLink);
               end
               poreNetwork.AddNewLinkData(diameters,'Diameter');
               duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
               disp(sprintf('Calcul du diam�tre des liens termin�. Dur�e : %d minutes %f s.',minutes,secondes));    
            end
            
            diameter=poreNetwork.GetLinkDataList.Diameter(iLink);
        end
        
        function diameter=GetPoreDiameter(poreNetwork,iPore)
            if not(isfield(poreNetwork.GetPoreDataList,'Diameter'))
            
                if not(isfield(poreNetwork.GetPoreDataList,'Volume'))
                    disp('Calcul du volume des pores...');tic;
                    volumes=ComputeAllPoreVolume(poreNetwork);
                    toc;
                    poreNetwork.AddNewPoreData(volumes,'Volume');
                    duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
                    disp(sprintf('Calcul du volume des pores termin�. Dur�e : %d minutes %f s.',minutes,secondes));
                end
                
                volumes=poreNetwork.GetPoreDataList.Volume;
                diameters=(24*volumes/(4*pi)).^(1/3);
                poreNetwork.AddNewPoreData(diameters,'Diameter');
            end
                
            diameter=poreNetwork.GetPoreDataList.Diameter(iPore);
            
        end
        
        
        
        %Frontieres
        function liens_frontiere=GetLinksFrontiere(poreNetwork,num_frontieres)
            %renvoie la liste des liens attach�s � une liste de frontieres
            %macroscopiques. Si num_frontiere=0, renvoie la liste des liens
            %internes.
            faces_frontieres=cell(1,length(num_frontieres));
            indice=1;
            for i=num_frontieres
                if i==0
                    start_face=poreNetwork.Boundaries.Boundary(end).ATTRIBUTE.StartFace+poreNetwork.Boundaries.Boundary(end).ATTRIBUTE.NombreFaces;
                    faces_frontieres{indice}=start_face:poreNetwork.GetNumberOfLinks;
                elseif i>0 && i<=length(poreNetwork.Boundaries.Boundary)
                    start_face=poreNetwork.Boundaries.Boundary(i).ATTRIBUTE.StartFace;
                    end_face=start_face+poreNetwork.Boundaries.Boundary(i).ATTRIBUTE.NombreFaces-1;
                    faces_frontieres{indice}=start_face:end_face;
                else
                    error('Trying to access links of non existing boundary');
                end
                indice=indice+1;
            end
            liens_frontiere=cell2mat(faces_frontieres);            
        end
        
        function numFrontiere=GetFrontiereOfLink(poreNetwork,numLink)
            numFrontiere=0;
            for iBoundary=1:length(poreNetwork.Boundaries.Boundary) 
                start=poreNetwork.Boundaries.Boundary(iBoundary).ATTRIBUTE.StartFace;
                finish=start+poreNetwork.Boundaries.Boundary(iBoundary).ATTRIBUTE.NombreFaces-1;
                if numLink>=start && numLink<=finish
                   numFrontiere=iBoundary ;
                end
            end
        end
        
        function pores_frontiere=GetPoresFrontiere(poreNetwork,linkFrontiere)
            %renvoie la liste des pores attach�s � une liste de liens situés sur une frontière. Un pore peut apparaitre plusieurs fois dans la
            %liste.
            faces=linkFrontiere;
            pores_frontiere=zeros(1,length(faces));
            for i=1:length(faces)
                pores_frontiere(i)=poreNetwork.FaceOwners(faces(i));
            end
        end
        
        
        
        function conductances=ComputeConductancesDiffusion(poreNetwork,numInlet,numOutlet)
            %V�rification si les diametres des liens sont d�j� calcul�s
            if not(isfield(poreNetwork.GetLinkDataList,'Diameter'))
                disp('Calcul du diam�tre des liens...');
                tic;
                nLink=poreNetwork.GetNumberOfLinks;
                diameter=zeros(1,nLink);
               for iLink=1:nLink
                    diameter(iLink)=poreNetwork.ComputeLinkDiameter(iLink);
               end
               poreNetwork.AddNewLinkData(diameter,'Diameter');
               duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
               disp(sprintf('Calcul du diam�tre des liens termin�. Dur�e : %d minutes %f s.',minutes,secondes));
            end
            
            diff_O2_dans_N2=2e-5;

            nLink=poreNetwork.GetNumberOfLinks;
            nPore=poreNetwork.GetNumberOfPores;
            linkDiameter=poreNetwork.GetLinkDataList.Diameter;
            linkSurface=(linkDiameter.^2).*(pi/4);
            dimension=poreNetwork.Dimension;

            poreCenter=zeros(nPore,dimension);
            for iPore=1:nPore
                poreCenter(iPore,:)=poreNetwork.GetPoreCenter(iPore);
            end
            
            linkCenter=zeros(nLink,dimension);
            for iLink=1:nLink
                linkCenter(iLink,:)=poreNetwork.GetLinkCenter(iLink);
            end
                           
            conductances=zeros(1,nLink);
            
            internalLinks=poreNetwork.GetLinksFrontiere(0);
            outletLinks=poreNetwork.GetLinksFrontiere(numOutlet);
            inletLinks=poreNetwork.GetLinksFrontiere(numInlet);
            
            for iLink=internalLinks
                surface=linkSurface(iLink);
                distance1=norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                distance2=norm(poreCenter(poreNetwork.FaceNeighbours(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=diff_O2_dans_N2*surface/(distance1+distance2);
            end

            for iLink=outletLinks
                surface=linkSurface(iLink);
                distance=2*norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=diff_O2_dans_N2*surface/distance;
            end
            
            for iLink=inletLinks
                surface=linkSurface(iLink);
                distance=2*norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=diff_O2_dans_N2*surface/distance;
            end
            
        end

                
        function conductances=ComputeConductancesStokes(poreNetwork,numInlet,numOutlet)
            viscosite_dyn_water=1e-3;
            
            nLink=poreNetwork.GetNumberOfLinks;
            nPore=poreNetwork.GetNumberOfPores;
            linkDiameter=poreNetwork.GetLinkDataList.Diameter;
            linkSurface=(linkDiameter.^2).*(pi/4);
            dimension=poreNetwork.Dimension;

            poreCenter=zeros(nPore,dimension);
            for iPore=1:nPore
                poreCenter(iPore,:)=poreNetwork.GetPoreCenter(iPore);
            end
            
            linkCenter=zeros(nLink,dimension);
            for iLink=1:nLink
                linkCenter(iLink,:)=poreNetwork.GetLinkCenter(iLink);
            end
                           
            conductances=zeros(1,nLink);
            
            internalLinks=poreNetwork.GetLinksFrontiere(0);
            outletLinks=poreNetwork.GetLinksFrontiere(numOutlet);
            inletLinks=poreNetwork.GetLinksFrontiere(numInlet);
            
            for iLink=internalLinks
                surface=linkSurface(iLink);
                distance1=norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                distance2=norm(poreCenter(poreNetwork.FaceNeighbours(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=surface^2/(8*pi*viscosite_dyn_water*(distance1+distance2));
            end

            for iLink=outletLinks
                surface=linkSurface(iLink);
                distance=2*norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=surface^2/(8*pi*viscosite_dyn_water*(distance));
            end
            
            for iLink=inletLinks
                surface=linkSurface(iLink);
                distance=2*norm(poreCenter(poreNetwork.FaceOwners(iLink),:)-linkCenter(iLink,:));
                conductances(iLink)=surface^2/(8*pi*viscosite_dyn_water*(distance));
            end

        end       
        
        
        
        function output=ComposantesConnexes(poreNetwork,liste_pores_envahis)
            %Retourne les composantes connexes des zones envahies par une
            %phase. 
            num_composante=1;
            pores_envahis_explores=zeros(1,length(liste_pores_envahis));
            %pores_envahis_explores(i)=0 si liste_pores_envahis(i) n'est
            %pas encore explor�, =num_composante sinon
            
            %boucle sur les composantes connexes
            %stack_pores_a_explorer=LifoStack;
            stack_pores_a_explorer=java.util.Stack();
            while not(length(find(pores_envahis_explores))==length(liste_pores_envahis))
                
                %algo : parcours en profondeur d'un amas
                %impl�mentation avec pile LIFO contenant les pores � explorer :  
                %on d�pile un pore et on empile ses voisins non encore explor�s.

                %initialisation avec un pore non explor�
                foo=find(pores_envahis_explores==0);
                stack_pores_a_explorer.push(foo(1)); 

                while ~stack_pores_a_explorer.empty
                    ref_pore=stack_pores_a_explorer.pop;
                    %ref_pore : position dans la liste_pore_envahis   
                    if pores_envahis_explores(ref_pore)==0
                        ref_voisins_envahis=find(ismember(liste_pores_envahis,poreNetwork.GetPoresVoisinsOfPore(liste_pores_envahis(ref_pore))));
                        %les voisins sont les pores ayant un lien commun,
                        %on suppose que les liens sont automatiquement
                        %envahis
                        ref_voisins_envahis_non_explores=ref_voisins_envahis(ismember(ref_voisins_envahis,find(~pores_envahis_explores)));   
                        for i=1:length(ref_voisins_envahis_non_explores)
                            stack_pores_a_explorer.push(ref_voisins_envahis_non_explores(i));
                        end
                        pores_envahis_explores(ref_pore)=num_composante;
                    end
                end
                num_composante=num_composante+1;
            end
            
            output=cell(1,max(pores_envahis_explores));
            for num_composante=1:max(pores_envahis_explores)
                output{num_composante}=liste_pores_envahis(pores_envahis_explores==num_composante);
            end
        end
           
        
        
        function output_struct=InternalOutputStruct(poreNetwork)
            %cr�ation de la structure output qui �crite dans le
            %fichier r�seau de pores ou visualis�e
            output_struct=struct;
            
            output_struct.FaceOwners=poreNetwork.FaceOwners;
            output_struct.FaceNeighbours=poreNetwork.FaceNeighbours;               
            output_struct.Boundaries=poreNetwork.Boundaries;            
            output_struct.Cells.Cell=poreNetwork.Pores;    
            
            attribute.Dimension=poreNetwork.Dimension;
            attribute.NombreFaces=poreNetwork.NombreFaces;
            attribute.NombrePores=poreNetwork.NombrePores;
            attribute.Type='PoreNetwork';
            output_struct.ATTRIBUTE=attribute;
            
        end
                   
    end

end

