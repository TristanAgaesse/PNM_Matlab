classdef ClusterMonophasique < handle
    %CLUSTERMONOPHASIQUE Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        InvadedPores
        BooleanInvadedLinks
        InterfaceLinks
        InterfacePoresOutward %si ext�rieur : 0 pour outlet, -1 pour wall
    end
    
    methods
        function cluster=ClusterMonophasique(invadedPores,interfaceLinks,poresFrontiereOutward,booleanInvadedLinks)
            %Constructeur
            cluster.InvadedPores=invadedPores;
            cluster.InterfaceLinks=interfaceLinks;
            cluster.InterfacePoresOutward=poresFrontiereOutward;
            cluster.BooleanInvadedLinks=booleanInvadedLinks;
        end
        
        function linksToUpdatePressure=InvadeNewPore(cluster,indexInvadedLink,poreNetwork)
            %G�re l'envahissement d'un nouveau pore par un lien donn� par
            %son indice indexInvadedLink dans la liste cluster.InterfaceLinks
            
            invadedLink=cluster.InterfaceLinks(indexInvadedLink);
            assert(ismember(invadedLink,cluster.InterfaceLinks),'Le lien envahi n''est pas sur la frontiere du cluster !')
            %envahir le pore associ�
            time=length(find(cluster.InvadedPores))+1;
            newInvadedPore=cluster.InterfacePoresOutward(indexInvadedLink);
            assert(newInvadedPore>0,'Impossible d''envahir l''exterieur du domaine !');
            cluster.InvadedPores(time)=newInvadedPore;

            %mettre a jour les listes rep�rant la position de la fronti�re
            link_of_invaded_pore=poreNetwork.GetLinksOfPore(cluster.InvadedPores(time));

            all_new_invaded_links=intersect(link_of_invaded_pore,cluster.InterfaceLinks);
            cluster.BooleanInvadedLinks(all_new_invaded_links)=1*ones(1,length(all_new_invaded_links));
            newLinks=setdiff(link_of_invaded_pore,all_new_invaded_links);

            linksToDelete=ismember(cluster.InterfaceLinks,all_new_invaded_links);
            cluster.InterfaceLinks=[cluster.InterfaceLinks(~linksToDelete),newLinks];

            pore_outward_of_new_links=zeros(1,length(newLinks));
            for iLink=1:length(newLinks)
                pore_outward_of_new_links(iLink)=setdiff(poreNetwork.GetPoresOfLink(newLinks(iLink)),cluster.InvadedPores(time));
            end
            cluster.InterfacePoresOutward=[cluster.InterfacePoresOutward(~linksToDelete),pore_outward_of_new_links];


            %liste des liens dont il faut updater la pression
            unique_new_pore_outward=unique(pore_outward_of_new_links);
            linksToUpdatePressure=cell(1,length(unique_new_pore_outward));
            for iPore=1:length(unique_new_pore_outward)
                linksToUpdatePressure{iPore}{1}=unique_new_pore_outward(iPore);
                linksToUpdatePressure{iPore}{2}=cluster.InterfaceLinks(ismember(cluster.InterfacePoresOutward,unique_new_pore_outward(iPore)));
            end
        end
        
        function InvadeOutletLink(cluster,indexOutletPore,linkOutlet,poreNetwork)
            invadedOutletLinks=intersect(poreNetwork.GetLinksOfPore(indexOutletPore),linkOutlet);
            cluster.BooleanInvadedLinks(invadedOutletLinks)=1*ones(1,length(invadedOutletLinks));
            [cluster.InterfaceLinks,index]=setdiff(cluster.InterfaceLinks,invadedOutletLinks);
            cluster.InterfacePoresOutward=cluster.InterfacePoresOutward(index);
        end
        
        function links=GetInvadedLinks(cluster)
            links=find(cluster.BooleanInvadedLinks);
        end
        
        function pores=GetInvadedPores(cluster)
            pores=cluster.InvadedPores(cluster.InvadedPores>0);
        end        
                
        function pore=GetOutwardPore(cluster,indexLink)
            pore=cluster.InterfacePoresOutward(indexLink);
        end
        
        function links=GetInterfaceLinks(cluster)
            links=cluster.InterfaceLinks;
        end
        
        function poresPercolants=FindPercolationPath(cluster,numInlet,numOutlet,poreNetwork)
            %Trouver les chemins de percolation : composantes connexes de 
            %pores envahis d�bouchant sur l'inlet et l'outlet
            invadedPoresList=cluster.GetInvadedPores;
            linkInlet=poreNetwork.GetLinksFrontiere(numInlet);
            linkOutlet=poreNetwork.GetLinksFrontiere(numOutlet);
            pores_outlet=poreNetwork.GetPoresFrontiere(linkOutlet);
            pores_inlet=poreNetwork.GetPoresFrontiere(linkInlet);
            
            pore_envahis_outlet=intersect(invadedPoresList,pores_outlet);
            pore_envahis_inlet=intersect(invadedPoresList,pores_inlet);
            
            num_chemin=1;
            poresPercolants={};
            composantes_connexes_du_fluide=poreNetwork.ComposantesConnexes(invadedPoresList);
            for num_composante=1:length(composantes_connexes_du_fluide)
                if ~isempty(intersect(composantes_connexes_du_fluide{num_composante},pore_envahis_outlet)) && ~isempty(find(ismember(composantes_connexes_du_fluide{num_composante},pore_envahis_inlet),1))
                    
                    invadedPores=composantes_connexes_du_fluide{num_composante};
                    linkCount=zeros(1,poreNetwork.GetNumberOfLinks);
                    for iPore=invadedPores
                        thoseLinks=poreNetwork.GetLinksOfPore(iPore);
                        linkCount(thoseLinks)=linkCount(thoseLinks)+1;
                    end
                    
                    booleanInvadedLinks=linkCount>0;
                    interfaceLinks=find(linkCount==1);
                    poresFrontiereOutward=[];
                    
                    percolatingCluster=ClusterMonophasique(invadedPores,interfaceLinks,poresFrontiereOutward,booleanInvadedLinks);
                    poresPercolants{num_chemin}=percolatingCluster;
                    num_chemin=num_chemin+1;
                end
            end

        end
        
        function newCriticalPressures=UpdateCriticalPressure(cluster,criticalPressures,linksToUpdatePressure,linkInlet,linkOutlet,poreNetwork)         
            %Met � jour les pressions critiques � la fronti�re d'un amas
            %liquide lorsqu'un nouveau pore est envahi.
            %input : liens_a_inspecter=structure : 
            %   linksToUpdatePressure=cell array, {{num_pore_outward},{[num_liens]}}
            optionCoalescence='numberOfInvadedNeighbours';
            optionCriticalPressure='criticalPressureOnFibers';
                        
            newCriticalPressures=criticalPressures;
            
            theta=poreNetwork.LinkDataList.LinkDatas.ContactAngle;
            
            for j=1:length(linksToUpdatePressure)
                pore=linksToUpdatePressure{j}{1};
                liens=linksToUpdatePressure{j}{2};
                nLien=length(liens);
                
                if pore==-1
                    %liens sur une frontiere
                    for iLien=liens
                        frontiere=poreNetwork.GetFrontiereOfLink(iLien);
                        if ismember(iLien,linkInlet) %inlet
                            newCriticalPressures(iLien)=Inf ;
                        
                        elseif ismember(iLien,linkOutlet) %outlet
                            if strcmp(optionCriticalPressure,'criticalPressureOnFibers')
                                newCriticalPressures(iLien)=ClusterMonophasique.criticalPressureOnFibersWithoutCoalescence(poreNetwork,iLien);
                            end
                            
                        else %wall
                            newCriticalPressures(iLien)=Inf ;
                        end
                    end
                    
                else %liens internes
                    coordinance=length(poreNetwork.GetLinksOfPore(pore));
                    for iLien=liens
                        
                        if strcmp(optionCriticalPressure,'criticalPressureOnFibers')
                            Pc=ClusterMonophasique.criticalPressureOnFibersWithoutCoalescence(poreNetwork,iLien);
                        end
                        
                        if strcmp(optionCoalescence,'none')
                            coalescenceFactor=1;
                            
                        elseif strcmp(optionCoalescence,'numberOfInvadedNeighbours')
                            if theta(iLien)<pi/2 %cas hydrophile
                                coalescenceFactor=(1-(nLien-1)/coordinance);
                            else %cas hydrophobe
                                coalescenceFactor=1;
                            end
                            
                        elseif strcmp(optionCoalescence,'angularPosition')
                            
                            
                        end
                        
                        newCriticalPressures(iLien)=coalescenceFactor*Pc;
                    end
                end
            end
        end

        
        function booleanArray=GetInvadedPoresBooleans(cluster,poreNetwork)
            booleanArray=zeros(1,poreNetwork.GetNumberOfPores);
            for iPore=cluster.GetInvadedPores
                booleanArray(iPore)=1;
            end
        end
        
        function compCluster=ComplementaryCluster(cluster,poreNetwork)
            %Trouve le cluster compl�mentaire correspondant aux pores non
            %envahis d'un cluster donn�.
            
            compInvadedPores=setdiff((1:poreNetwork.GetNumberOfPores),cluster.GetInvadedPores);
            compBooleanInvadedLinks=not(cluster.BooleanInvadedLinks);
            compInterfaceLinks=cluster.GetInterfaceLinks;
            
            compInterfacePoresOutward=[];                                                            % TO DO
                        
            compCluster=ClusterMonophasique(compInvadedPores,compInterfaceLinks,compInterfacePoresOutward,compBooleanInvadedLinks);
        end
        
    end
    
    methods (Static=true)
        function [cluster, criticalPressures]=InitialiseInvasionCluster(linkInlet,linkOutlet,poreNetwork)
            %listes qui rep�rent les pores et les liens envahis
            nPore=poreNetwork.GetNumberOfPores;
            invadedPores=zeros(1,nPore);
            
            nLink=poreNetwork.GetNumberOfLinks;
            booleanInvadedLinks=zeros(1,nLink);
            
            %listes qui rep�rent la position de la fronti�re
            interfaceLinks=linkInlet;
            poresFrontiereOutward=poreNetwork.GetPoresFrontiere(linkInlet);   
            
            cluster=ClusterMonophasique(invadedPores,interfaceLinks,poresFrontiereOutward,booleanInvadedLinks);
            
            %initialisation des pressions critiques
            [b,~,m]=unique(poresFrontiereOutward);
            linksToInitialise=cell(1,length(b));
            for i=1:length(b)
                linksToInitialise{i}{1}=b(i);
            end
            for i=1:length(poresFrontiereOutward)
                linksToInitialise{m(i)}{end+1}=poresFrontiereOutward(i);
            end
            criticalPressures=zeros(1,poreNetwork.GetNumberOfLinks);
            criticalPressures=cluster.UpdateCriticalPressure(criticalPressures,linksToInitialise,linkInlet,linkOutlet,poreNetwork);
        end
        
        function Pc=criticalPressureOnFibersWithoutCoalescence(poreNetwork,iLien)
            sigmaWater=60e-3;
            
            numEdges=poreNetwork.FacesToEdges{iLien};
            diametresFibres=poreNetwork.GetEdgeDataList.DiametreFibre;
            fibreDiameter=mean(diametresFibres(numEdges));
            contactAngle=poreNetwork.GetLinkDataList.ContactAngle;
            theta=contactAngle(iLien);
            diameters=poreNetwork.GetLinkDataList.Diameter;
            linkDiameter=diameters(iLien);
            alpha=theta-pi+asin(sin(theta)/(1+linkDiameter/fibreDiameter));
            Pc=-(4*sigmaWater/linkDiameter)*cos(theta-alpha)/(1+fibreDiameter*(1-cos(alpha))/(linkDiameter));
        end
        
        
    end
    
end

