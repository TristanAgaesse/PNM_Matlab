classdef PoreNetworkMeshFibrous < PoreNetworkMesh
    %PoreNetworkMeshFibrous Summary of this class goes here
    %   Detailed explanation goes here
    
    properties %(SetAccess = protected, GetAccess = protected)
        Edges %Tableau 2*NombreEdges contenant les num�ros des vertices d�finissant les edges.
        NombreEdges
        VerticesToEdges
        FacesToEdges
        EdgeDataList
        
    end
    
    methods                       
        %constructeur � partir de l'input geometrie_macroscopique
        %doit renseigner toutes les properties de la geometrie consid�r�e
        function poreNetworkMeshFibrous=PoreNetworkMeshFibrous(dimension,faces,pores,cells_to_vertices,owners,neighbours,boundaries,vertices,edges,vertices_to_edges,epaisseur_edges,faces_to_edges)
            poreNetworkMeshFibrous=poreNetworkMeshFibrous@PoreNetworkMesh(dimension,faces,pores,cells_to_vertices,owners,neighbours,boundaries,vertices);

            
            poreNetworkMeshFibrous.Edges=edges;
            poreNetworkMeshFibrous.NombreEdges=length(edges(:,1));
            dataEdgeList=DataEdgeList(poreNetworkMeshFibrous.NombreEdges);
            poreNetworkMeshFibrous.EdgeDataList=dataEdgeList;
            dataEdgeList.AddData('DiametreFibre',epaisseur_edges);
            poreNetworkMeshFibrous.VerticesToEdges=vertices_to_edges;
            poreNetworkMeshFibrous.FacesToEdges=faces_to_edges;
        end
        
        function vertices=GetVerticesOfEdge(poreNetwork,numEdge)
            vertices=poreNetwork.Vertices(poreNetwork.Edges(numEdge,:),:);
        end
        
        function vertNum=GetVerticesOfEdgeNumber(poreNetwork,numEdge)
            vertNum=poreNetwork.Edges(numEdge,:);
        end
                
        function edges=GetEdgesOfLink(poreNetwork,numLink)
            edges=poreNetwork.FacesToEdges{numLink};
        end
        
        function edges=GetEdgesOfPore(poreNetwork,numPore)
            links=poreNetwork.GetLinksOfPore(numPore);
            edges=[];
            for iLink=links
                edges=[edges,poreNetwork.GetEdgesOfLink(iLink)];
            end
            edges=unique(edges);
        end
        
        function number=GetNumberOfEdges(poreNetwork)
            number=poreNetwork.NombreEdges;
        end
        
        function neighbourLinks=GetNeighbourLinksOfEdgeInPore(poreNetwork,numPore,numEdge)
            neighbourLinks=[];
            poreLinks=poreNetwork.GetLinksOfPore(numPore);
            for iLink=poreLinks
                linkEdges=poreNetwork.GetEdgesOfLink(iLink);
                if ismember(numEdge,linkEdges)
                    neighbourLinks=[neighbourLinks,iLink];
                end
            end
            assert(length(neighbourLinks)==2);
        end
                
        
        
        function dataStruct=GetEdgeDataList(poreNetwork)
            dataStruct=poreNetwork.EdgeDataList.EdgeDatas;
        end       
        
        function NewEdgeData(poreNetwork,data,name)
            poreNetwork.EdgeDataList.AddData(name,data);
        end
        
        
        
        function volume=ComputePoreVolume(poreNetwork, numPore)
            fibreDiameter=poreNetwork.GetEdgeDataList.('DiametreFibre');
            nodes=poreNetwork.GetVerticesOfPore(numPore);
            centrePore=mean(nodes);
            
            switch poreNetwork.Dimension
                case 3
                    
                    links=poreNetwork.GetLinksOfPore(numPore);
                    nFace=length(links);
                    faces = minConvexHull(nodes);

                    edges=poreNetwork.GetEdgesOfPore(numPore);
                    for iEdge=edges
                        neighbourFaces=poreNetwork.GetNeighbourLinksOfEdgeInPore(numPore,iEdge);

                        foo=poreNetwork.GetVerticesOfLink(neighbourFaces(1)) ;
                        pointsPlan1=foo([1 2 3 3],:);
                        vect1=Mailleur.ComputeVecteurNormalOrienteExterieurBlock(pointsPlan1,centrePore);

                        foo=poreNetwork.GetVerticesOfLink(neighbourFaces(2)) ;
                        pointsPlan2=foo([1 2 3 3],:);
                        vect2=Mailleur.ComputeVecteurNormalOrienteExterieurBlock(pointsPlan2,centrePore);

                        dihedralAngle=pi-acos(dot(vect1,vect2));
                        planeNormal=-(vect1+vect2)/norm(vect1+vect2);
                        distance=fibreDiameter(iEdge)/2*sqrt(dihedralAngle/(2*tan(dihedralAngle/2))) ;
                        foo=poreNetwork.GetVerticesOfEdge(iEdge);
                        P0=foo(1,:)+distance*planeNormal;
                        plane=createPlane(P0,-planeNormal);
                        try 
                            [nodes, faces] = clipConvexPolyhedronHP(nodes, faces, plane);
                        catch
                                nodes=0;
                                disp(sprintf('Probleme en calculant volume du pore %d',numPore));
                        end
                    end
                    if size(nodes,1)<3
                        volume=0;
                    else
                        [~, volume] = convhulln(nodes);
                    end
            
                case 2
                    volume=abs(polygonArea(nodes));
            
            end
            
            
        end
        
        function volume=ComputeAllPoreVolume(poreNetwork)
            nPore=poreNetwork.GetNumberOfPores;
            volume=zeros(1,nPore);
            for iPore=1:nPore
                volume(iPore)=poreNetwork.ComputePoreVolume(iPore);                
            end
        end        
        
        function linkDiameter=ComputeLinkDiameter(poreNetwork, numLink)
            %Calcule le diametre equivalent d'un lien en extrudant les
            %fibres
            verticesExtrudes=poreNetwork.ComputeExtrudeFaceParFibre(numLink);
            
            switch poreNetwork.Dimension
                case 2
                    if ~isempty(verticesExtrudes)
                        linkDiameter=norm(verticesExtrudes(1,:)-verticesExtrudes(2,:));
                    else
                        linkDiameter=0;
                    end
                case 3
                    surface=abs(polygonArea(verticesExtrudes));%librairie mathgeom
                    linkDiameter=sqrt(4*surface/pi); %diam�tre �quivalent
            end
        end
        
        function verticesExtrudes=ComputeExtrudeFaceParFibre(poreNetwork, numLink)
            %renvoie les sommets du polygone obtenu en extrudant une face
            %par des fibres.
            
            dimension=poreNetwork.Dimension;
            switch dimension
                case 2
                    numVertices=poreNetwork.Faces{numLink};
                    vertices=poreNetwork.Vertices(numVertices,:);
                    foo=vertices(2,:)-vertices(1,:);
                    largeur=norm(foo);
                    foo=foo/largeur;
                    
                    numEdges=poreNetwork.FacesToEdges{numLink};
                    r1=poreNetwork.GetEdgeDataList.DiametreFibre(numEdges(1))/2;
                    r2=poreNetwork.GetEdgeDataList.DiametreFibre(numEdges(2))/2;
                    if largeur>r1+r2
                        verticesExtrudes=zeros(2,2);
                        verticesExtrudes(1,:)=vertices(1,:)+r1*foo;
                        verticesExtrudes(2,:)=vertices(2,:)-r2*foo;
                    else
                        verticesExtrudes=[];
                    end
                    
                case 3
                    numVertices=poreNetwork.Faces{numLink};
                    polygon=PolygoneProjetterDansPlan(poreNetwork.Vertices(numVertices,:));
                    %polygon=polygon(PolygoneOrdonnerSommetsDansPlan(polygon),:);
                    numEdges=poreNetwork.FacesToEdges{numLink};
                    
                    for i=1:length(numVertices)
                        thisVertice=numVertices(i);
                        if i<length(numVertices)
                            otherVertice=numVertices(i+1);
                        else
                            otherVertice=numVertices(1);
                        end
                        numFibre=numEdges(i);
                        diametreFibre=poreNetwork.GetEdgeDataList.DiametreFibre(numFibre);

                        line=parallelLine(createLine(thisVertice, otherVertice),-diametreFibre/2);
                        polygon=clipPolygonHP(polygon, line);%librairie mathgeom
                    end
                    
                    verticesExtrudes=polygon;
            end
            
            
               
        end
        
        
        
        function outputStruct=InternalOutputStruct(poreNetworkMeshFibrous)
            %cr�ation en m�moire de la structure output qui pourra �tre 
            %visualis�e par le visualisateur interne
            outputStruct=poreNetworkMeshFibrous.InternalOutputStruct@PoreNetworkMesh;
            %ajouter champs manquants et changer ATTRIBUTE.Type
            outputStruct.Edges=poreNetworkMeshFibrous.Edges;
            outputStruct.EdgeData.DiametreFibre=poreNetworkMeshFibrous.EdgeDataList.EdgeDatas.DiametreFibre;
            outputStruct.ATTRIBUTE.Type='PoreNetworkUnstructuredMeshFibrous';
            outputStruct.ATTRIBUTE.NombreEdges=poreNetworkMeshFibrous.NombreEdges;
        end
        
        function vtk_struct=VTKOutputStruct(pore_network)
            %cr�ation en m�moire de la structure d'un fichier VTK POLYDATA 
            %pour afficher le r�seau de pores dans paraview.
            vertices=pore_network.Vertices;
            edges=pore_network.Edges;
            faces=pore_network.Faces;
            cells=pore_network.Cells;
            pore_data=pore_network.GetPoreDataList;
            link_data=pore_network.GetLinkDataList;
            edge_data=pore_network.GetEdgeDataList;
            vertice_data=pore_network.GetVerticeDataList;
            dimension=pore_network.Dimension;

            %Partie POINTS du fichier
            nCell=length(cells);
            nombre_points_pour_cells=0;
            for iCell=1:nCell
                liste_faces=cells{iCell};
                for iFace=liste_faces
                   nombre_points_pour_cells=nombre_points_pour_cells+length(faces{iFace}); 
                end
            end
            nEdge=length(edges(:,1));
            nVertice=length(vertices(:,1));
            nPoints=2*nEdge+sum(cellfun('length',faces))+nombre_points_pour_cells+nVertice;
            points_output=zeros(nPoints,3);
                        
            edge_to_points=cell(1,nEdge);
            x_extension=max(vertices(:,1))-min(vertices(:,1));
            y_extension=max(vertices(:,2))-min(vertices(:,2));
            z_extension=(x_extension+y_extension)/20;
            for iEdge=1:nEdge
                if dimension==3
                    points_output((2*iEdge-1),:)=vertices(edges(iEdge,1),:);
                    points_output((2*iEdge),:)=vertices(edges(iEdge,2),:);
                else
                    points_output((2*iEdge-1),:)=[vertices(edges(iEdge,1),:),0];
                    points_output((2*iEdge),:)=[vertices(edges(iEdge,2),:),-z_extension];
                end
                edge_to_points{iEdge}=[(2*iEdge-1),(2*iEdge)];
            end
          
            compteur_debut=2*nEdge+1;

            nFace=length(faces);
            face_to_points=cell(1,nFace);
            for iFace=1:nFace
                compteur_fin=compteur_debut+length(faces{iFace})-1;
                if dimension==3
                    points_output((compteur_debut:compteur_fin),:)=vertices(faces{iFace},:);
                else
                    points_output((compteur_debut:compteur_fin),:)=horzcat(vertices(faces{iFace},:),zeros(length(faces{iFace}),1));
                end
                face_to_points{iFace}=(compteur_debut):(compteur_fin);
                compteur_debut=compteur_fin+1;
            end
            
            cell_to_points=cell(1,nCell);
            for iCell=1:nCell
                liste_faces=cells{iCell};
                cell_to_points{iCell}=cell(1,length(liste_faces));
                centre=mean(vertices(pore_network.CellsToVertices{iCell},:));
                i=0;
                for iFace=liste_faces
                    i=i+1;
                    compteur_fin=compteur_debut+length(faces{iFace})-1;
                    %new_vertices=0.999*(vertices(faces{iFace},:)-ones(length(vertices(faces{iFace})),1)*centre)+ones(length(vertices(faces{iFace})),1)*centre;
                    if dimension==3
                        %points_output((compteur_debut:compteur_fin),:)=new_vertices;
                        points_output((compteur_debut:compteur_fin),:)=vertices(faces{iFace},:);
                    else
                        %points_output((compteur_debut:compteur_fin),:)=horzcat(new_vertices,zeros(length(faces{iFace}),1));
                        points_output((compteur_debut:compteur_fin),:)=horzcat(vertices(faces{iFace},:),zeros(length(faces{iFace}),1));
                    end                   
                    cell_to_points{iCell}{i}=(compteur_debut):(compteur_fin);
                    compteur_debut=compteur_fin+1;
                end
            end
            
            compteur_fin=compteur_debut+nVertice-1;
            if dimension==3
                points_output((compteur_debut:compteur_fin),:)=vertices;
            else
                points_output((compteur_debut:compteur_fin),:)=horzcat(vertices,zeros(nVertice,1));
            end
            vertices_to_points=cell(1,nVertice);
            for i=1:nVertice
                vertices_to_points{i}=compteur_debut+i-1;
            end
            compteur_debut=compteur_fin+1;
            
            assert(compteur_debut==nPoints+1);
            
            %Partie LINES du fichier
            nLine=nEdge;
            lines_output=zeros(nLine,3);
            for iLine=1:nLine
                lines_output(iLine,1)=2;
                lines_output(iLine,2)=edge_to_points{iLine}(1)-1;
                lines_output(iLine,3)=edge_to_points{iLine}(2)-1;
            end
            
            %Partie POLYGONS du fichier
            nCellPolygone=sum(cellfun('length',cells));
            nPolygone=nFace+nCellPolygone;
            polygons_output=cell(nPolygone,1);
            face_to_polygon=cell(1,nFace);
            for iFace=1:nFace
                foo=face_to_points{iFace}-1;
                polygons_output{iFace}=[length(foo),foo];
                face_to_polygon{iFace}=iFace;
            end
            compteur=nFace+1;
            cell_to_polygon=cell(1,nCell);
            for iCell=1:nCell
                cell_to_polygon{iCell}=compteur:(compteur+length(cells{iCell})-1);
                for i=1:length(cells{iCell})
                    foo=cell_to_points{iCell}{i}-1;
                    polygons_output{compteur}=[length(foo),foo];
                    compteur=compteur+1;
                end
            end
            assert((compteur-1)==length(polygons_output));
            
            %Partie VERTICES du fichier
            vertices_output=horzcat(ones(nVertice,1),transpose((nPoints-nVertice+1):nPoints));
            
            
            %Partie POINT_DATA du fichier
            point_data_output=struct;
                %transcription des edge data
            names=fieldnames(edge_data);
            for i=1:length(names)
                data_output=zeros(nPoints,1);
                data=edge_data.(names{i});
                for iEdge=1:nEdge
                    data_output(edge_to_points{iEdge}(1))=data(iEdge);
                    data_output(edge_to_points{iEdge}(2))=data(iEdge);
                end
                point_data_output.(strcat('Edge_',names{i}))=data_output;
            end
                %transcription des vertices data
            names=fieldnames(vertice_data);
            for i=1:length(names)
                data_output=zeros(nPoints,1);
                data=vertice_data.(names{i});
                for iVertice=1:nVertice
                    data_output(vertices_to_points{iVertice})=data(iVertice);
                end
                point_data_output.(strcat('Vertice_',names{i}))=data_output;
            end    
                
              
            
            %Partie CELL_DATA du fichier
            nCellData=nLine+nPolygone+nVertice;
            cell_data_output=struct;
                %transcription des link data
            names=fieldnames(link_data);
            for i=1:length(names)
                data_output=zeros(nCellData,1);
                data=link_data.(names{i});
                for iFace=1:nFace
                    data_output(face_to_polygon{iFace}+nLine+nVertice)=data(iFace);
                end
                cell_data_output.(strcat('Link_',names{i}))=data_output;
            end
                %transcription des pore data
            names=fieldnames(pore_data);
            for i=1:length(names)
                data_output=zeros(nCellData,1);
                data=pore_data.(names{i});
                for iCell=1:nCell
                    data_output(cell_to_polygon{iCell}+nLine+nVertice)=data(iCell)*ones(length(cell_to_polygon{iCell}),1);
                end
                cell_data_output.(strcat('Pore_',names{i}))=data_output;
            end

            vtk_struct.Points=points_output;
            vtk_struct.Lines=lines_output;
            vtk_struct.Polygons=polygons_output;
            vtk_struct.Vertices=vertices_output;
            vtk_struct.PointData=point_data_output;
            vtk_struct.CellData=cell_data_output;
        end       
        
        function VTKWritingInterface(network)
            file_name=input('Entrez un nom de fichier pour visualiser le r�seau de pores dans paraview s''il vous pla�t : \n');
            writer=FileWriterVTK(file_name);
            tic;
            disp('G�n�ration du fichier VTK...');
            donnees_output=network.VTKOutputStruct;
            writer.Write(donnees_output);
            duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
            disp(sprintf('Fichier VTK g�n�r�. Dur�e : %d minutes %f s.',minutes,secondes));
            writer.delete;clear('writer','file_name','file_content','donnees_output','duree','minutes','secondes');
        end
                       
    end
    
end
