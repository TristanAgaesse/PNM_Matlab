function [clusterLiquide,criticalPressures,breakthroughPressure] = ComputeInvasionPercolation(poreNetwork,linkInlet,linkOutlet,wettability)
%ComputeInvasionPercolation Calcule l'invasion de percolation sur un r�seau
%de pores, avec un unique cluster
%Input :- network
%       - linkInlet : liste des liens d'injection   
%       -linkOutlet : liste des liens de percée possible
%       - wettability : 'hydrophobic', 'hydrophilic' or 'mixtedWettability'


    %V�rification si les diametres des liens sont d�j� calcul�s
    if not(isfield(poreNetwork.GetLinkDataList,'Diameter'))
        disp('Calcul du diam�tre des liens...');
        tic;
        nLink=poreNetwork.GetNumberOfLinks;
        diameter=zeros(1,nLink);
        for iLink=1:nLink
            diameter(iLink)=poreNetwork.ComputeLinkDiameter(iLink);
        end
        poreNetwork.AddNewLinkData(diameter,'Diameter');
        duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
        disp(sprintf('Calcul du diam�tre des liens termin�. Dur�e : %d minutes %f s.',minutes,secondes));
    end
    
    %V�rification si les contact angles des liens sont d�finis
    if not(isfield(poreNetwork.GetLinkDataList,'ContactAngle'))
        disp('Contact Angles non encore d�finis.');
        nLink=poreNetwork.GetNumberOfLinks;
        contactAngles=zeros(1,nLink);
        
        for iLink=1:nLink
            if strcmp(wettability,'hydrophobic')
                contactAngles(iLink)=pi*110/180;
            elseif strcmp(wettability,'hydrophilic')
                contactAngles(iLink)=pi*80/180;
            elseif strcmp(wettability,'mixtedWettability')
                contactAngles(iLink)=pi*(80+30*rand)/110;
            end
        end
        poreNetwork.AddNewLinkData(contactAngles,'ContactAngle');
    end
    
    %Pr�paration de l'invasion : initialisation du clusterLiquide.
    disp('Calcul d''invasion percolation...');
    tic;

    [clusterLiquide, criticalPressures]=ClusterMonophasique.InitialiseInvasionCluster(linkInlet,linkOutlet,poreNetwork);
    
    %Boucle d'invasion pore par pore
    time=0;
    currentPressure=0;
    outlet_reached=false;
    outletPores=poreNetwork.GetPoresFrontiere(linkOutlet);
    nPore=poreNetwork.GetNumberOfPores;
    
    while not(outlet_reached)
        assert(time<nPore+1);
        time=time+1;
        %trouver la face de plus petite pression critique
        interfaceLinks=clusterLiquide.GetInterfaceLinks;
        [invasionPressure,indexInvadedLink]=min(criticalPressures(interfaceLinks));
        invadedPore=clusterLiquide.GetOutwardPore(indexInvadedLink);
        
        if invasionPressure>currentPressure
            currentPressure=invasionPressure;
        end
            
            
        %envahir le pore associ�
        linksToUpdatePressure=clusterLiquide.InvadeNewPore(indexInvadedLink,poreNetwork);
        %mettre � jour pressions critiques
        criticalPressures=clusterLiquide.UpdateCriticalPressure(criticalPressures,linksToUpdatePressure,linkInlet,linkOutlet,poreNetwork);
        
        %v�rifier si outlet_reached
        if ismember(invadedPore,outletPores)
            outlet_reached=true;
            clusterLiquide.InvadeOutletLink(invadedPore,linkOutlet,poreNetwork);
        end
    end
    breakthroughPressure=currentPressure;
    
    duree=toc;minutes=floor(duree/60);secondes=duree-60*minutes;
    disp(sprintf('Calcul d''invasion percolation termin�. Dur�e : %d minutes %f s.',minutes,secondes));
    
end